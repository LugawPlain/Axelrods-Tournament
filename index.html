<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axelrod's Prisoner's Dilemma Tournament</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .grid-cell { transition: all 0.1s; }
        
        /* Custom scrollbar for the timeline and grid */
        .custom-scroll::-webkit-scrollbar { height: 6px; width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #a0a0a0; }

        .selected-cell {
            border: 2px solid #6366f1 !important; /* Indigo-500 */
            z-index: 10;
            transform: scale(1.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="p-2 md:p-6 lg:p-8 min-h-screen">

    <div class="max-w-[1600px] mx-auto">
        <header class="mb-4 md:mb-6 flex flex-col md:flex-row justify-between items-center bg-white p-4 md:p-6 rounded-xl shadow-sm border border-gray-100 gap-4">
            <div class="text-center md:text-left">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Axelrod's Tournament</h1>
                <p class="text-gray-500 mt-1 text-xs md:text-sm">Select a grid cell for match details.</p>
            </div>
            
            <div class="flex flex-wrap justify-center items-center gap-2 md:gap-3 w-full md:w-auto">
                <div class="text-right mr-2 md:mr-4 border-r pr-4 md:pr-6 border-gray-200 hidden sm:block">
                    <div class="text-[10px] md:text-xs text-gray-400 uppercase tracking-wider">Round</div>
                    <div class="text-2xl md:text-4xl font-mono font-bold text-indigo-600" id="round-display">0/200</div>
                </div>
                <div class="sm:hidden w-full text-center text-indigo-600 font-mono font-bold text-xl mb-2" id="round-display-mobile">
                    Round: 0/200
                </div>
                
                <div class="flex gap-2 w-full md:w-auto justify-center">
                    <button onclick="stepGame()" class="flex-1 md:flex-none bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-3 py-2 rounded-lg font-medium transition flex justify-center items-center gap-2 text-sm">
                        <span>⏯</span> <span class="hidden sm:inline">Step</span>
                    </button>

                    <button onclick="togglePlay()" id="play-btn" class="flex-1 md:flex-none bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-medium transition flex justify-center items-center gap-2 shadow-sm text-sm min-w-[100px]">
                        <span id="play-icon">▶</span> Auto-Play
                    </button>

                    <button onclick="resetGame()" class="flex-1 md:flex-none bg-gray-100 hover:bg-gray-200 text-gray-600 px-3 py-2 rounded-lg font-medium transition text-sm">
                        Reset
                    </button>
                </div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 items-start">
            
            <div class="lg:col-span-7 bg-white p-2 md:p-4 rounded-xl shadow-sm border border-gray-100 overflow-hidden">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
                    <h2 class="text-lg font-semibold text-gray-700">Tournament Grid</h2>
                    <div class="flex flex-wrap gap-2 md:gap-3 text-[10px] md:text-xs font-normal bg-gray-50 p-2 rounded-lg w-full sm:w-auto">
                        <span class="flex items-center gap-1"><div class="w-2 h-2 md:w-3 md:h-3 bg-green-500 rounded-sm"></div> (C,C)</span>
                        <span class="flex items-center gap-1"><div class="w-2 h-2 md:w-3 md:h-3 bg-red-500 rounded-sm"></div> (D,D)</span>
                        <span class="flex items-center gap-1"><div class="w-2 h-2 md:w-3 md:h-3 bg-yellow-400 rounded-sm"></div> A Wins</span>
                        <span class="flex items-center gap-1"><div class="w-2 h-2 md:w-3 md:h-3 bg-blue-500 rounded-sm"></div> B Wins</span>
                    </div>
                </div>
                
                <div class="overflow-x-auto custom-scroll pb-2">
                    <div class="min-w-[500px] md:min-w-0"> <div class="flex">
                             <div id="left-labels" class="flex mt-6 flex-col justify-around w-20 md:w-24 mr-2 text-right shrink-0"></div>
                            
                            <div class="flex flex-col flex-grow">
                                <div id="top-labels" class="flex flex-row text-center gap-[2px] w-full mb-1 pl-1"></div>
                                
                                <div id="grid-container" class="grid grid-cols-15 gap-[2px] bg-gray-100 p-1 rounded border border-gray-200 aspect-square w-full">
                                    </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-5 flex flex-col gap-6">
                
                <div id="match-detail-panel" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden flex flex-col transition-all duration-300">
                    <div class="p-3 md:p-4 border-b border-gray-100 bg-gray-50 flex justify-between items-center">
                        <h2 class="text-xs md:text-sm font-bold text-gray-700 uppercase tracking-wide">Match Analysis</h2>
                        <span id="detail-coordinates" class="text-[10px] md:text-xs font-mono text-gray-400">Select a cell</span>
                    </div>

                    <div id="detail-content-placeholder" class="p-6 md:p-8 text-center text-gray-400 text-sm">
                        Click on any square in the grid to view the round-by-round timeline.
                    </div>

                    <div id="detail-content" class="hidden flex-col">
                        <div class="grid grid-cols-2 text-center border-b border-gray-100">
                            <div class="p-2 md:p-3 border-r border-gray-100 bg-white">
                                <div id="p1-name" class="font-bold text-gray-800 text-xs md:text-sm truncate px-1">Strategy A</div>
                                <div id="p1-score" class="text-xl md:text-2xl font-mono text-indigo-600 font-bold">0</div>
                            </div>
                            <div class="p-2 md:p-3 bg-white">
                                <div id="p2-name" class="font-bold text-gray-800 text-xs md:text-sm truncate px-1">Strategy B</div>
                                <div id="p2-score" class="text-xl md:text-2xl font-mono text-indigo-600 font-bold">0</div>
                            </div>
                        </div>

                        <div class="p-3 md:p-4 bg-gray-50 border-b border-gray-200">
                            <h3 class="text-[10px] font-semibold text-gray-500 mb-2 uppercase">Interaction Timeline</h3>
                            <div class="custom-scroll overflow-x-auto pb-2">
                                <div id="timeline-container" class="flex gap-1" style="min-width: max-content;">
                                    </div>
                            </div>
                        </div>

                        <div class="p-2 md:p-3 text-[10px] md:text-xs text-gray-500 bg-white flex justify-between">
                            <span>Scoring: (C,C)=3, (D,D)=1, (D,C)=5/0</span>
                            <span id="detail-round-count">Round 0</span>
                        </div>
                    </div>
                </div>

                <div class="bg-white p-4 md:p-6 rounded-xl shadow-sm border border-gray-100 flex-grow flex flex-col h-[400px] lg:h-auto">
                    <h2 class="text-lg font-semibold mb-2 md:mb-4 text-gray-700">Live Standings</h2>
                    <p class="text-xs text-gray-400 mb-2">Click any strategy to see its logic.</p>
                    <div class="overflow-y-auto pr-2 flex-grow custom-scroll" id="leaderboard" style="max-height: 500px;">
                        </div>
                </div>

            </div>
        </div>

        <div id="strategy-modal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm p-4" onclick="closeModal()">
            <div class="bg-white rounded-xl shadow-2xl p-6 max-w-lg w-full transform transition-all scale-95 opacity-0" id="modal-content" onclick="event.stopPropagation()">
                <div class="flex justify-between items-start mb-4">
                    <h2 id="modal-title" class="text-xl md:text-2xl font-bold text-gray-800">Strategy Name</h2>
                    <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 p-1">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="bg-indigo-50 p-4 rounded-lg border border-indigo-100 mb-4">
                    <p id="modal-desc" class="text-gray-700 text-sm md:text-base leading-relaxed"></p>
                </div>
                <div class="text-xs text-gray-500 text-right">
                    Based on Axelrod's "The Evolution of Cooperation"
                </div>
            </div>
        </div>

        <footer class="mt-8 text-center text-[10px] md:text-xs text-gray-400 border-t border-gray-200 pt-4 pb-8">
            <p class="px-4">The strategies implemented here are approximations based on descriptions from Robert Axelrod's "The Evolution of Cooperation".</p>
        </footer>

    </div>

    <script>
        // --- Game Constants & State ---
        const MAX_ROUNDS = 200; 
        let currentRound = 0;
        let isPlaying = false;
        let intervalId = null;
        let speed = 25; 

        // Payoffs
        const R = 3; 
        const P = 1; 
        const T = 5; 
        const S = 0; 

        const COOP = 0;
        const DEFECT = 1;

        // Selection State
        let selectedMatch = { row: null, col: null };

        // --- Strategy Definitions ---
        const getLastMove = (history) => history.length > 0 ? history[history.length - 1] : null;
        
        // 1. TIT FOR TAT
        const titForTat = (myHistory, oppHistory) => {
            if (oppHistory.length === 0) return COOP;
            return oppHistory[oppHistory.length - 1];
        };

        // 2. TIDEMAN AND CHIERUZZI
        const tideman = (myHistory, oppHistory, myScore, oppScore) => {
            if (oppHistory.length === 0) return COOP;
            if (myScore < oppScore - 10 && currentRound > 20 && myHistory[myHistory.length-1] === DEFECT) {
                return COOP; 
            }
            return oppHistory[oppHistory.length - 1];
        };

        // 3. NYDEGGER
        const nydegger = (myHistory, oppHistory) => {
            if (oppHistory.length < 3) return (oppHistory.length === 0) ? COOP : titForTat(myHistory, oppHistory);
            let A = 0;
            for (let i = 1; i <= 3; i++) {
                let idx = oppHistory.length - i;
                let oppM = oppHistory[idx];
                let myM = myHistory[idx];
                let val = 0;
                if (myM === COOP && oppM === COOP) val = 0;
                else if (myM === DEFECT && oppM === COOP) val = 1;
                else if (myM === COOP && oppM === DEFECT) val = 2;
                else val = 3;
                let weight = (i===3) ? 16 : (i===2) ? 4 : 1;
                A += val * weight;
            }
            const defectSet = [1, 6, 7, 17, 22, 23, 26, 29, 30, 31, 33, 38, 39, 45, 49, 54, 55, 58, 61];
            return defectSet.includes(A) ? DEFECT : COOP;
        };

        // 4. GROFMAN
        const grofman = (myHistory, oppHistory) => {
            if (oppHistory.length === 0) return COOP;
            const lastOpp = oppHistory[oppHistory.length - 1];
            const lastMy = myHistory[myHistory.length - 1];
            if (lastOpp !== lastMy) {
                return (Math.random() < (2/7)) ? COOP : DEFECT;
            }
            return COOP;
        };

        // 5. SHUBIK
        const shubik = (myHistory, oppHistory) => {
             if (oppHistory.length === 0) return COOP;
             let retaliationCount = 0;
             let inRun = false;
             for(let m of oppHistory) {
                 if(m === DEFECT && !inRun) { retaliationCount++; inRun = true; }
                 else if (m === COOP) inRun = false;
             }
             if (getLastMove(oppHistory) === DEFECT) return DEFECT;
             
             let lastOppDefectIdx = oppHistory.lastIndexOf(DEFECT);
             if (lastOppDefectIdx === -1) return COOP;
             
             let turnsSince = oppHistory.length - 1 - lastOppDefectIdx;
             if (turnsSince < retaliationCount) return DEFECT;
             return COOP;
        };

        // 6. STEIN AND RAPOPORT
        const stein = (myHistory, oppHistory) => {
            const r = currentRound + 1;
            if (r <= 4) return COOP;
            if (r >= MAX_ROUNDS - 1) return DEFECT;
            return titForTat(myHistory, oppHistory);
        };

        // 7. FRIEDMAN (Grudger)
        const friedman = (myHistory, oppHistory) => {
            if (oppHistory.includes(DEFECT)) return DEFECT;
            return COOP;
        };

        // 8. DAVIS
        const davis = (myHistory, oppHistory) => {
            if (currentRound < 10) return COOP;
            if (oppHistory.includes(DEFECT)) return DEFECT;
            return COOP;
        };

        // 9. GRAASKAMP
        const graaskamp = (myHistory, oppHistory) => {
            const r = currentRound + 1;
            if (r === 51) return DEFECT;
            if (r > 52 && r % 15 === 0) return DEFECT; 
            return titForTat(myHistory, oppHistory);
        };

        // 10. DOWNING
        const downing = (myHistory, oppHistory) => {
            if (currentRound === 0) return DEFECT;
            if (currentRound === 1) return DEFECT; 
            let c_c = 0, c_total = 0, d_c = 0, d_total = 0;
            for(let i=0; i<myHistory.length-1; i++) {
                if (myHistory[i] === COOP) {
                    c_total++;
                    if (oppHistory[i+1] === COOP) c_c++;
                } else {
                    d_total++;
                    if (oppHistory[i+1] === COOP) d_c++;
                }
            }
            let prob_c_given_c = c_total === 0 ? 0.5 : c_c / c_total;
            let prob_c_given_d = d_total === 0 ? 0.5 : d_c / d_total;
            let ev_coop = prob_c_given_c * 3 + (1 - prob_c_given_c) * 0;
            let ev_defect = prob_c_given_d * 5 + (1 - prob_c_given_d) * 1;
            return (ev_coop > ev_defect) ? COOP : DEFECT;
        };

        // 11. FELD
        const feld = (myHistory, oppHistory) => {
            if (oppHistory.length > 0 && oppHistory[oppHistory.length-1] === DEFECT) return DEFECT;
            const prob = 1.0 - (currentRound / MAX_ROUNDS) * 0.5;
            return (Math.random() < prob) ? COOP : DEFECT;
        };

        // 12. JOSS
        const joss = (myHistory, oppHistory) => {
            if (oppHistory.length === 0) return COOP;
            if (oppHistory[oppHistory.length-1] === DEFECT) return DEFECT;
            return (Math.random() < 0.10) ? DEFECT : COOP;
        };

        // 13. TULLOCK
        const tullock = (myHistory, oppHistory) => {
            if (currentRound < 11) return COOP;
            const last10 = oppHistory.slice(-10);
            const coopCount = last10.filter(m => m === COOP).length;
            const oppCoopRate = coopCount / 10;
            const myProb = Math.max(0, oppCoopRate - 0.10);
            return (Math.random() < myProb) ? COOP : DEFECT;
        };

        // 14. NAME WITHHELD
        const unnamed = (myHistory, oppHistory) => {
             if (currentRound === 0) return (Math.random() < 0.3) ? COOP : DEFECT;
             const oppCoops = oppHistory.filter(m => m === COOP).length;
             const rate = oppCoops / oppHistory.length;
             if (rate > 0.7) return COOP;
             return (Math.random() < 0.3) ? COOP : DEFECT;
        };

        // 15. RANDOM
        const randomStrat = () => (Math.random() < 0.5) ? COOP : DEFECT;

        const strategies = [
            { 
                name: "Tit For Tat", 
                func: titForTat, 
                id: 0, 
                color: "border-blue-500", 
                desc: "Cooperates on the first move. For every subsequent move, it simply copies the opponent's previous move. It is nice (never defects first), forgiving (retaliates only once), and provokable." 
            },
            { 
                name: "Tideman & Chieruzzi", 
                func: tideman, 
                id: 1, 
                color: "border-indigo-500", 
                desc: "A complex strategy that retaliates to defections but tries to break cycles of mutual defection if it falls far behind, effectively offering a 'fresh start' to a punishing opponent." 
            },
            { 
                name: "Nydegger", 
                func: nydegger, 
                id: 2, 
                color: "border-purple-500", 
                desc: "Determines its move based on a weighted formula of the last 3 outcomes. It checks if the calculated value exists in a predefined 'defect set'. It is generally stoic and cooperative but not easily exploited." 
            },
            { 
                name: "Grofman", 
                func: grofman, 
                id: 3, 
                color: "border-pink-500", 
                desc: "If the moves in the previous round differed, it cooperates with probability 2/7. Otherwise, it cooperates. This randomness helps prevent getting stuck in alternating defect loops." 
            },
            { 
                name: "Shubik", 
                func: shubik, 
                id: 4, 
                color: "border-red-500", 
                desc: "Retaliates with increasing severity. The length of its retaliation string (series of defects) increases by 1 each time the opponent defects against it." 
            },
            { 
                name: "Stein & Rapoport", 
                func: stein, 
                id: 5, 
                color: "border-orange-500", 
                desc: "A modification of Tit For Tat. It cooperates unconditionally for the first 4 moves, defects unconditionally for the last 2 moves (to squeeze end-game points), and plays Tit For Tat in between." 
            },
            { 
                name: "Friedman", 
                func: friedman, 
                id: 6, 
                color: "border-yellow-500", 
                desc: "Also known as 'Grudger'. It cooperates until the opponent defects just once. After that single betrayal, it defects forever and never forgives." 
            },
            { 
                name: "Davis", 
                func: davis, 
                id: 7, 
                color: "border-lime-500", 
                desc: "Cooperates for the first 10 moves to build trust. If the opponent defects at any point (even during the first 10), it switches to a 'Grudger' strategy and defects forever." 
            },
            { 
                name: "Graaskamp", 
                func: graaskamp, 
                id: 8, 
                color: "border-green-500", 
                desc: "Plays Tit For Tat for 50 moves. On move 51, it defects to seize an advantage. It also checks every 15 moves and defects randomly to test if the opponent can be exploited." 
            },
            { 
                name: "Downing", 
                func: downing, 
                id: 9, 
                color: "border-teal-500", 
                desc: "Estimates the probability that the opponent will cooperate given its own previous move. It acts to maximize its expected payoff based on these running estimates. Starts by Defecting." 
            },
            { 
                name: "Feld", 
                func: feld, 
                id: 10, 
                color: "border-cyan-500", 
                desc: "Plays Tit For Tat, but the probability of maintaining cooperation declines linearly over the course of the game. It becomes increasingly aggressive as the game nears the end." 
            },
            { 
                name: "Joss", 
                func: joss, 
                id: 11, 
                color: "border-sky-500", 
                desc: "Plays Tit For Tat, but with a nasty twist: it defects 10% of the time even when it 'should' cooperate. This random aggression tries to exploit nice strategies but often causes conflict spirals." 
            },
            { 
                name: "Tullock", 
                func: tullock, 
                id: 12, 
                color: "border-indigo-400", 
                desc: "Cooperates for 11 moves. Then, it cooperates with a probability that is 10% less than the opponent's cooperation rate over the last 10 moves. It punishes lack of cooperation slightly more harshly." 
            },
            { 
                name: "Name Withheld", 
                func: unnamed, 
                id: 13, 
                color: "border-violet-400", 
                desc: "A submission that remained anonymous. It acts randomly initially but attempts to align its behavior if the opponent shows a high frequency of cooperation (>70%)." 
            },
            { 
                name: "Random", 
                func: randomStrat, 
                id: 14, 
                color: "border-gray-400", 
                desc: "The baseline control. It essentially flips a coin every turn. 50% chance to Cooperate, 50% chance to Defect, regardless of history." 
            }
        ];

        // --- Tournament State ---
        let matches = [];
        let totalScores = new Array(15).fill(0);

        function initTournament() {
            matches = [];
            totalScores = new Array(15).fill(0);
            
            for (let i = 0; i < 15; i++) {
                matches[i] = [];
                for (let j = 0; j < 15; j++) {
                    matches[i][j] = {
                        historyA: [],
                        historyB: [],
                        scoreA: 0,
                        scoreB: 0
                    };
                }
            }
            renderGridStructure();
            updateUI();
        }

        function playRound() {
            if (currentRound >= MAX_ROUNDS) {
                stopGame();
                return;
            }

            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const match = matches[i][j];
                    const stratA = strategies[i];
                    const stratB = strategies[j];

                    const moveA = stratA.func(match.historyA, match.historyB, match.scoreA, match.scoreB);
                    const moveB = stratB.func(match.historyB, match.historyA, match.scoreB, match.scoreA);

                    match.historyA.push(moveA);
                    match.historyB.push(moveB);

                    let payoffA = 0;
                    let payoffB = 0;

                    if (moveA === COOP && moveB === COOP) {
                        payoffA = R; payoffB = R;
                    } else if (moveA === DEFECT && moveB === DEFECT) {
                        payoffA = P; payoffB = P;
                    } else if (moveA === DEFECT && moveB === COOP) {
                        payoffA = T; payoffB = S;
                    } else {
                        payoffA = S; payoffB = T;
                    }

                    match.scoreA += payoffA;
                    match.scoreB += payoffB;
                }
            }

            // Update Totals
            totalScores.fill(0);
            for(let i=0; i<15; i++) {
                for(let j=0; j<15; j++) {
                    totalScores[i] += matches[i][j].scoreA;
                }
            }

            currentRound++;
            updateUI();
        }

        // --- Interaction Functions ---

        function stepGame() {
            // If playing, pause first
            if (isPlaying) {
                stopGame();
                updatePlayButton();
            }
            // Advance one
            playRound();
        }

        function selectMatch(i, j) {
            // Deselect old
            if (selectedMatch.row !== null) {
                const old = document.getElementById(`cell-${selectedMatch.row}-${selectedMatch.col}`);
                if (old) old.classList.remove('selected-cell');
            }
            
            selectedMatch = { row: i, col: j };
            
            const cell = document.getElementById(`cell-${i}-${j}`);
            if (cell) cell.classList.add('selected-cell');

            renderMatchDetails();
            
            // On mobile, scroll to details
            if (window.innerWidth < 1024) {
                 document.getElementById('match-detail-panel').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function showStrategyInfo(index) {
            const s = strategies[index];
            document.getElementById('modal-title').innerText = s.name;
            document.getElementById('modal-desc').innerText = s.desc;
            
            const modal = document.getElementById('strategy-modal');
            const content = document.getElementById('modal-content');
            
            modal.classList.remove('hidden');
            // Small timeout for animation
            setTimeout(() => {
                content.classList.remove('scale-95', 'opacity-0');
                content.classList.add('scale-100', 'opacity-100');
            }, 10);
        }

        function closeModal() {
            const modal = document.getElementById('strategy-modal');
            const content = document.getElementById('modal-content');
            
            content.classList.remove('scale-100', 'opacity-100');
            content.classList.add('scale-95', 'opacity-0');
            
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 200);
        }

        // --- UI Rendering ---

        function renderGridStructure() {
            const grid = document.getElementById('grid-container');
            const topLabels = document.getElementById('top-labels');
            const leftLabels = document.getElementById('left-labels');
            
            grid.innerHTML = '';
            topLabels.innerHTML = '';
            leftLabels.innerHTML = '';
            
            // Labels
            strategies.forEach((s, idx) => {
                const tl = document.createElement('div');
                tl.className = 'w-full text-center text-[10px] md:text-[12px] text-gray-500 font-mono cursor-pointer hover:font-bold hover:text-indigo-600 transition-colors truncate';
                tl.innerText = (idx+1); 
                tl.title = `Click for info: ${s.name}`;
                tl.onclick = () => showStrategyInfo(idx);
                topLabels.appendChild(tl);

                const ll = document.createElement('div');
                ll.className = 'text-[9px] md:text-[10px] text-gray-600 font-medium truncate h-full flex items-center justify-end cursor-pointer hover:text-indigo-600 hover:font-bold transition-colors';
                ll.innerText = s.name;
                ll.onclick = () => showStrategyInfo(idx);
                leftLabels.appendChild(ll);
            });

            // Grid Cells
            grid.style.gridTemplateColumns = 'repeat(15, minmax(0, 1fr))';
            
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const cell = document.createElement('div');
                    cell.id = `cell-${i}-${j}`;
                    cell.className = 'grid-cell w-full h-full rounded-[1px] md:rounded-sm bg-gray-200 relative cursor-pointer border border-white/50 hover:brightness-95';
                    cell.onclick = () => selectMatch(i, j);
                    grid.appendChild(cell);
                }
            }
        }

        function renderMatchDetails() {
            const { row, col } = selectedMatch;
            const placeholder = document.getElementById('detail-content-placeholder');
            const content = document.getElementById('detail-content');
            const coords = document.getElementById('detail-coordinates');

            if (row === null || col === null) {
                placeholder.classList.remove('hidden');
                content.classList.add('hidden');
                coords.innerText = "Select a cell";
                return;
            }

            placeholder.classList.add('hidden');
            content.classList.remove('hidden');
            content.classList.add('flex');

            const sA = strategies[row];
            const sB = strategies[col];
            const match = matches[row][col];

            coords.innerText = `Grid [${row+1}, ${col+1}]`;
            
            document.getElementById('p1-name').innerText = sA.name;
            document.getElementById('p2-name').innerText = sB.name;
            document.getElementById('p1-score').innerText = match.scoreA;
            document.getElementById('p2-score').innerText = match.scoreB;
            document.getElementById('detail-round-count').innerText = `Round ${currentRound}`;

            // Render Timeline
            const timeline = document.getElementById('timeline-container');
            timeline.innerHTML = '';

            // If no moves yet
            if (match.historyA.length === 0) {
                timeline.innerHTML = '<div class="w-full text-center text-gray-400 text-xs py-4">Waiting for start...</div>';
                return;
            }

            // Generate Columns
            for(let r=0; r<match.historyA.length; r++) {
                const mA = match.historyA[r];
                const mB = match.historyB[r];
                
                // Calc points for this specific round
                let pA = 0, pB = 0;
                if (mA === COOP && mB === COOP) { pA=3; pB=3; }
                else if (mA === DEFECT && mB === DEFECT) { pA=1; pB=1; }
                else if (mA === DEFECT && mB === COOP) { pA=5; pB=0; }
                else { pA=0; pB=5; }

                const colDiv = document.createElement('div');
                colDiv.className = 'flex flex-col gap-[2px] items-center min-w-[18px] md:min-w-[24px]';

                // Round Number (every 5)
                const num = document.createElement('div');
                num.className = 'text-[8px] md:text-[9px] text-gray-300 h-3 leading-3';
                num.innerText = (r+1) % 5 === 0 ? (r+1) : '';
                colDiv.appendChild(num);

                // Player A Move
                const boxA = document.createElement('div');
                boxA.className = `w-4 h-4 md:w-6 md:h-6 rounded-[2px] md:rounded flex items-center justify-center text-[8px] md:text-[10px] font-bold text-white shadow-sm ${mA===COOP ? 'bg-green-500' : 'bg-red-500'}`;
                boxA.innerText = pA;
                colDiv.appendChild(boxA);

                // Connector line
                const line = document.createElement('div');
                line.className = 'w-[1px] h-1 md:h-2 bg-gray-200';
                colDiv.appendChild(line);

                // Player B Move
                const boxB = document.createElement('div');
                boxB.className = `w-4 h-4 md:w-6 md:h-6 rounded-[2px] md:rounded flex items-center justify-center text-[8px] md:text-[10px] font-bold text-white shadow-sm ${mB===COOP ? 'bg-green-500' : 'bg-red-500'}`;
                boxB.innerText = pB;
                colDiv.appendChild(boxB);

                timeline.appendChild(colDiv);
            }

            // Auto scroll to end
            const scrollContainer = document.querySelector('.timeline-scroll');
            if (scrollContainer) scrollContainer.scrollLeft = scrollContainer.scrollWidth;
            // Also scroll the inner container if referenced differently
            const tlContainer = document.getElementById('timeline-container')?.parentElement;
            if (tlContainer) tlContainer.scrollLeft = tlContainer.scrollWidth;
        }

        function updateUI() {
            const displayStr = `${currentRound}/${MAX_ROUNDS}`;
            document.getElementById('round-display').innerText = displayStr;
            document.getElementById('round-display-mobile').innerText = `Round: ${displayStr}`;

            // Update Grid Colors
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    const match = matches[i][j];
                    
                    if (match.historyA.length === 0) continue;

                    const lastA = match.historyA[match.historyA.length - 1];
                    const lastB = match.historyB[match.historyB.length - 1];

                    let colorClass = 'bg-gray-200';
                    if (lastA === COOP && lastB === COOP) colorClass = 'bg-green-500';
                    else if (lastA === DEFECT && lastB === DEFECT) colorClass = 'bg-red-500';
                    else if (lastA === DEFECT && lastB === COOP) colorClass = 'bg-yellow-400'; 
                    else if (lastA === COOP && lastB === DEFECT) colorClass = 'bg-blue-500'; 

                    // Keep selected class if selected
                    const isSelected = (selectedMatch.row === i && selectedMatch.col === j);
                    cell.className = `grid-cell w-full h-full rounded-[1px] md:rounded-sm relative cursor-pointer border border-white/50 hover:brightness-95 ${colorClass} ${isSelected ? 'selected-cell' : ''}`;
                }
            }

            updateLeaderboard();
            
            // Refresh detail view if something is selected
            if (selectedMatch.row !== null) {
                renderMatchDetails();
            }
        }

        function updateLeaderboard() {
            const board = document.getElementById('leaderboard');
            
            const sortedIndices = totalScores.map((score, index) => ({ score, index }))
                                           .sort((a, b) => b.score - a.score);
            
            board.innerHTML = '';
            
            sortedIndices.forEach((item, rank) => {
                const s = strategies[item.index];
                const row = document.createElement('div');
                row.className = 'flex items-center justify-between p-2 md:p-3 mb-2 rounded bg-gray-50 border-l-4 cursor-pointer hover:bg-gray-100 transition-colors ' + s.color;
                row.onclick = () => showStrategyInfo(item.index);
                
                let rankClass = "bg-gray-200 text-gray-600";
                if(rank===0) rankClass = "bg-yellow-100 text-yellow-700 font-bold";
                if(rank===1) rankClass = "bg-gray-200 text-gray-700 font-bold";
                if(rank===2) rankClass = "bg-orange-100 text-orange-800 font-bold";

                row.innerHTML = `
                    <div class="flex items-center gap-2 md:gap-3">
                        <span class="w-5 h-5 md:w-6 md:h-6 flex items-center justify-center rounded-full text-[10px] md:text-xs ${rankClass}">${rank+1}</span>
                        <span class="font-medium text-gray-700 text-xs md:text-sm truncate max-w-[120px] md:max-w-none">${s.name}</span>
                    </div>
                    <span class="font-mono font-bold text-indigo-600 text-sm md:text-base">${item.score}</span>
                `;
                board.appendChild(row);
            });
        }

        function updatePlayButton() {
            const btn = document.getElementById('play-btn');
            if (isPlaying) {
                btn.innerHTML = `<span>⏸</span> Pause`;
                btn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                btn.classList.add('bg-red-600', 'hover:bg-red-700');
            } else {
                btn.innerHTML = `<span id="play-icon">▶</span> Auto-Play`;
                btn.classList.remove('bg-red-600', 'hover:bg-red-700');
                btn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
        }

        function togglePlay() {
            if (isPlaying) {
                stopGame();
            } else {
                if (currentRound >= MAX_ROUNDS) resetGame();
                isPlaying = true;
                intervalId = setInterval(playRound, speed);
            }
            updatePlayButton();
        }

        function stopGame() {
            isPlaying = false;
            if (intervalId) clearInterval(intervalId);
            updatePlayButton();
        }

        function resetGame() {
            stopGame();
            currentRound = 0;
            initTournament();
            // Force redraw of empty details
            renderMatchDetails();
        }

        // Init
        initTournament();

    </script>
</body>
</html>